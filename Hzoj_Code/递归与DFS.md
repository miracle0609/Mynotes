[TOC]



#### #`83.N分`

[题目](http://oj.haizeix.com/problem/83)

**题解:**

层数是固定的，后面的数是>=前面的数，输出方法总数；

每一层从谁开始，选多少数，还应该选几个；



#### #`235.递归实现指数型枚举`

[题目](http://oj.haizeix.com/problem/235)

**题解：**

![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2011-12-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)
![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2011-13-24%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)



如果第一层是１那么第二层就应该从２开始，如果第一层是２那么下一层就应该从３开始；
递归函数：func(int s), s是从谁开始
n, num[15]记录，cnt 计数
保证下一层比本层大所以进行func(i + 1)
<font color = red>**他这是每次选择一个，就输出num[];**</font>






#### #`236.递归实现组合型枚举`

[题目](http://oj.haizeix.com/problem/236)

**题解：**

<font color = red>**什么时候能选够ｍ个数就输出num[]**</font>





#### #`237.递归实现排列型枚举`

[题目](http://oj.haizeix.com/problem/237)

**题解：**
后面的数可以比前面数小，与前两个题不同，所以每次遍历要从１～ｎ，为了避免重复，开一个标记组
<font color = red>**也是选择ｍ个数输出num[]，避免重复要标记**</font>
回溯的时候标记别忘取消了；



#### #`240.图形打印四`

[题目](http://oj.haizeix.com/problem/240)

**题解：**

![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2010-27-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

当ｎ= 1时边长为１，当ｎ= 2时边长为３,当ｎ=3时，边长为９，....27...81...243....

可以由左上角对五个位置进行填充，可得

设边长为num[n]

左上角:(`x, y`);

右上角:(`x, y + num[n]/3*2`)

左下角:(`x + num[n]/3*2, y`)

右下角:(`x + num[n]/3*2, y + num[n]/3*2`)

中心：(`x + num[n]/3, y + num[n]/3`)

主要思路是将从１～７个全部打印出来，最后进行选择

当递归到１时将二维字符数组对应的ｘ, y打印成'X'，也就是递归出口；

因为２是由１转变过来的，３是由２转变过来的，４是由３转变过来的，即可递归回溯

#### #`396填涂颜色`

[题目](http://oj.haizeix.com/problem/396)

题解: 可以先在外围加一堵0墙，然后进行对外围搜0，然后都标记为３，最后将全部扫一遍，将０变为２，３变０即可：

>```
>0 0 0 0 0 0
>0 0 1 1 1 1
>0 1 0 0 0 1
>1 0 0 0 0 1
>1 0 0 0 0 1
>1 1 1 1 1 1
>```
>```
>0 0 0 0 0 0 0 0 //先在外围加一堵0墙
>0 0 0 1 1 1 1 0//然后进行对外围搜0，然后都标记为３
>0 0 1 0 0 0 1 0
>0 1 0 0 0 0 1 0
>0 1 0 0 0 0 1 0
>0 1 1 1 1 1 1 0
>0 0 0 0 0 0 0 0
>```
>
>```
>0 0 0 0 0 0//最后将全部扫一遍，将０变为２，３变０即可：
>0 0 1 1 1 1
>0 1 1 2 2 1
>1 1 2 2 2 1
>1 2 2 2 2 1
>1 1 1 1 1 1
>```

#### #`397僵尸来袭`

[题目](http://oj.haizeix.com/problem/397)

题解: 

直接对二维数组遍历，在便利的同时如果非０那就开始搜索，进行吧能搜到的所有僵尸变为０，直至最后，记录了几次调用函数搜索即可！

模拟一下：

```
0 1 2 3 4 0
1 0 0 0 0 0
2 9 3 0 2 4
0 0 2 0 2 8
1 0 0 0 0 0
```

```
0 0 0 0 0 0
1 0 0 0 0 0
2 9 3 0 2 4      第一次
0 0 2 0 2 8
1 0 0 0 0 0
```

```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 2 4      第二次
0 0 0 0 2 8
1 0 0 0 0 0
```

```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0      第三次
0 0 0 0 0 0
1 0 0 0 0 0
```

```
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0      第四次
0 0 0 0 0 0
0 0 0 0 0 0
```

#### #`404  01迷宫简易版`

[题目](http://oj.haizeix.com/problem/404)

题解: 

如果上一次坐标与本次坐标不同即可走，然后把标记数组置为１，加数；

此题用到了记录数组；切记刚开始坐标对应的标记数组应该置为一；

#### #`405  01迷宫`

[题目](http://oj.haizeix.com/problem/405)

题解: 

本体由于数量大，按正常思路走会超时，所以本题使用了用队列记录了所要能到达的坐标位置，计数，到一小块结束后，将队列所存的坐标对应全赋值为这一块计数的那个值，继续同理操作，到最后只要索引下表就可以快速找到多大；

#### #`406水坑数量`

[题目](http://oj.haizeix.com/problem/406)

题解: 

本题同３９７僵尸来袭，都是直接遍历二维数组，符合条件就直接搜进行原图标记，记录搜了几波就ＯＫ了；

#### #`534体积`

[题目](http://oj.haizeix.com/problem/534)

题解: 

此题就是235的改进，每走一步记录所走的当前路径的和，然后到最后去重，去重的时候可以使用标记数组，用sun当索引进行标记,记录最后有多少数就是表示不同提及的组合数

#### #`535瓷砖`

[题目](http://oj.haizeix.com/problem/535)

题解: 

直接DFS,先找到开始坐标，进行DFS,能走的地方一直走，每走一步记录一步sum++;最终sum就是最大能走多少；

#### #`536 最大黑色区域`

[题目](http://oj.haizeix.com/problem/536)

题解: 

从头开始走，每当能走时进行搜索记录本次搜索的步数，然后每一波搜索记录一下最大的值，然后就得到最大黑色区域的面积；

#### #`537门票问题`

[题目](http://oj.haizeix.com/problem/537)

题解: 

改进的236题;首先有一个记录路径的，而且还要记录元音和辅音有多少个为了当走了合法left时而且元音辅音符合条件时才能满足打印情况，就是这样。