[TOC]



#### #`83.N分`

[题目](http://oj.haizeix.com/problem/83)

**题解:**

层数是固定的，后面的数是>=前面的数，输出方法总数；

每一层从谁开始，选多少数，还应该选几个；



#### #`235.递归实现指数型枚举`

[题目](http://oj.haizeix.com/problem/235)

**题解：**

![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2011-12-06%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)
![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2011-13-24%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)



如果第一层是１那么第二层就应该从２开始，如果第一层是２那么下一层就应该从３开始；
递归函数：func(int s), s是从谁开始
n, num[15]记录，cnt 计数
保证下一层比本层大所以进行func(i + 1)
<font color = red>**他这是每次选择一个，就输出num[];**</font>






#### #`236.递归实现组合型枚举`

[题目](http://oj.haizeix.com/problem/236)

**题解：**

<font color = red>**什么时候能选够ｍ个数就输出num[]**</font>





#### #`237.递归实现排列型枚举`

[题目](http://oj.haizeix.com/problem/237)

**题解：**
后面的数可以比前面数小，与前两个题不同，所以每次遍历要从１～ｎ，为了避免重复，开一个标记组
<font color = red>**也是选择ｍ个数输出num[]，避免重复要标记**</font>
回溯的时候标记别忘取消了；



#### #`240.图形打印四`

[题目](http://oj.haizeix.com/problem/240)

**题解：**

![](%E9%80%92%E5%BD%92%E4%B8%8EDFS.assets/2020-03-12%2010-27-09%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png)

当ｎ= 1时边长为１，当ｎ= 2时边长为３,当ｎ=3时，边长为９，....27...81...243....

可以由左上角对五个位置进行填充，可得

设边长为num[n]

左上角:(`x, y`);

右上角:(`x, y + num[n]/3*2`)

左下角:(`x + num[n]/3*2, y`)

右下角:(`x + num[n]/3*2, y + num[n]/3*2`)

中心：(`x + num[n]/3, y + num[n]/3`)

主要思路是将从１～７个全部打印出来，最后进行选择

当递归到１时将二维字符数组对应的ｘ, y打印成'X'，也就是递归出口；

因为２是由１转变过来的，３是由２转变过来的，４是由３转变过来的，即可递归回溯



