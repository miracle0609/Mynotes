[TOC]





* [1.顺序表](#1顺序表)
* [2.链表](#2链表)
               [程序内部，内存内部](#程序内部内存内部)
               [链表翻转：](#链表翻转)
* [3.队列&栈](#3.队列&栈)
                   [（１）队列：先进先出](#１队列先进先出)
                   [（２）栈 ：后进先出](#２栈后进先出)
                   [<strong>循环队列：</strong>](#循环队列)
                   [<strong>栈：</strong>](#栈)
                   [栈的扩容：](#栈的扩容)
* [4.树与二叉树](#4树与二叉树)
               [树的结构定义](#树的结构定义)
                  [二叉树的存储](#二叉树的存储)
                  [二叉树的遍历](#二叉树的遍历)
                  [先序遍历](#先序遍历)
                  [中序遍历](#中序遍历)
                  [后序遍历](#后序遍历)
                  [已知先序和中序求后序](#已知先序和中序求后序)
                     [二叉树的线索化](#二叉树的线索化)
                     [二叉树转广义表](#二叉树转广义表)
                     [广义表转二叉树](#广义表转二叉树)
* [５.堆与优先队列](#５堆与优先队列)
                [<strong>堆：</strong>](#堆)
                   [<strong>优先队列</strong>](#优先队列)
                   [堆排序：](#堆排序)
* [６.排序算法](#６排序算法)
                   [稳定排序](#稳定排序)
                       [插入排序](#插入排序)
                       [归并排序](#归并排序)
                   [不稳定排序](#不稳定排序)
                      [选择排序](#选择排序)
                      [二分查找](#二分查找)
* [８.哈希表](#８哈希表)
* [９.二叉排序树](#９二叉排序树)
                   [插入:](#插入)
                   [删除:](#删除)
* [10.森林与并查集](#10森林与并查集)
                  [QUICK-FIND算法](#quick-find算法)
                  [QUICK-UNION算法](#quick-union算法)
                  [WEIGHTED QYICK-UNION算法](#weighted-qyick-union算法)

* [11.字符串匹配](#11.字符串匹配)




 数据结构 ＝ 结构定义 ＋ 结构操作



![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewz18xnubj30ye0a2n2m.jpg)

## 1.顺序表

![undefined](http://ww1.sinaimg.cn/large/006Uqzbtly1gewz6xuwz9j30vz0beq5c.jpg)

插入与删除两个操作

插入时：size = 9, length = 6, data_type = xxx

删除时：size = 9, length = 4, data_type = xxx

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct Vector {
    int *data;
    int size, length;
}Vector;

Vector *init(int n) {   //初始化顺序表
    Vector *vec = (Vector *)malloc(sizeof(Vector));
    vec->data = (int *)malloc(sizeof(int) * n);
    vec->size = n;
    vec->length = 0;
    return vec;
}

int insert(Vector *vec, int ind, int val) { //插入
    if(vec == NULL) return 0;
    if(ind < 0 || ind > vec->length) return 0;
    if(vec->length == vec->size)return 0;
    for(int i = vec->length; i > ind; i--) { // 因为下表从０开始的，所以这里移动后下表为ind~length;
        vec->data[i] = vec->data[i - 1];
    }
    vec->data[ind] = val;
    vec->length += 1;
    return 1;
}

int erase(Vector *vec, int ind) {　//　删除
    if(vec == NULL) return 0;
    if(ind < 0 || ind >= vec->length) return 0;
    for(int i = ind + 1; i < vec->length; i++) { // 删除后的下表从ｉｎｄ　＋　１开始往后都减１；
        vec->data[i - 1] = vec->data[i];
    }
    vec->length-=1;
    return 1;
}

void output(Vector *vec) {　//输出
    printf("Vector(%d) = [", vec->length);
    for(int i = 0; i < vec->length; i++) {
        i && printf(", ");
        printf("%d",vec->data[i]);

    }
    printf("]\n");
    return;
}

void clear(Vector *vec) {　// 清空释放
    if(vec == NULL) return;
    free(vec->data);//free数据域，再free指针 
    free(vec);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, ind, val;
    Vector *vec = init(max_op);
    for(int i = 0; i < max_op; i++) {
        op = rand() % 2;
        ind = rand() % (vec->length + 1);
        val = rand() % 100;
        switch(op) {
            case 0:{
                printf("insert %d at %d to Vector = %d\n",val, ind, insert(vec, ind, val));
            }break;
            case 1:{
                printf("earse item at %d from Vector = %d\n", ind, erase(vec, ind));
            }break;
        }
            output(vec);
            printf("\n");
    }
    clear(vec);
    return 0;
}
```
扩容：

`realloc`:１．先划分空间　２．将ｐ里内容拷贝到ｑ中　３．free(p)释放原来空间
此时如果扩容不成的话 此时`vec->data = NULL`了，找不到索引！

bug : 

```cpp
int expand(Vector *vec) {
    vec->size *= 2;
    vec->data = (int *)realloc(vec->data, sizeof(int) * vec->size);
    return 1;
}
```

改进：

```cpp
int expand2(Vector *vec) {
    int extr_size = vec->size;
    int *p;
    while(extr_size) {
        p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
        if(p)break;
        extr_size /= 2;
    }
    if(p == NULL) return 0;
    vec->data = p;
    vec->size += extr_size;
    return 1;
}
```



```cpp
int expand3(Vector *vec) {
    int *old_data = vec->data;
    vec->size *= 2;
    vec->data = (int *)malloc(sizeof(int) * vec->size);
    for(int i = 0; i < vec->length; i++) {
        vec->data[i] = old_data[i];
    }
    free(old_data);
    return 1;
}
```



最终代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct Vector {
    int *data;
    int size, length;
}Vector;

Vector *init(int n) {
    Vector *vec = (Vector *)malloc(sizeof(Vector));
    vec->data = (int *)malloc(sizeof(int) * n);
    vec->size = n;
    vec->length = 0;
    return vec;
}

int expand(Vector *vec) {
    int *old_data = vec->data;
    vec->size *= 2;
    vec->data = (int *)malloc(sizeof(int) * vec->size);
    for(int i = 0; i < vec->length; i++) {
        vec->data[i] = old_data[i];
    }
    free(old_data);
    return 1;
}

int expand2(Vector *vec) {
    int extr_size = vec->size;
    int *p;
    while(extr_size) {
        p = (int *)realloc(vec->data, sizeof(int) * (vec->size + extr_size));
        if(p)break;
        extr_size /= 2;
    }
    if(p == NULL) return 0;
    vec->data = p;
    vec->size += extr_size;
    return 1;
}

int insert(Vector *vec, int ind, int val) {
    if(vec == NULL) return 0;
    if(ind < 0 || ind > vec->length) return 0;
    if(vec->length == vec->size) {
        if(!expand(vec)) return 0;
        printf("expand successfully ! size = %d\n", vec->size);
    }
    for(int i = vec->length; i > ind; i--) {
        vec->data[i] = vec->data[i - 1];
    }
    vec->data[ind] = val;
    vec->length += 1;
    return 1;
}

int erase(Vector *vec, int ind) {
    if(vec == NULL) return 0;
    if(ind < 0 || ind >= vec->length) return 0;
    for(int i = ind + 1; i < vec->length; i++) {
        vec->data[i - 1] = vec->data[i];
    }
    vec->length-=1;
    return 1;
}

void output(Vector *vec) {
    printf("Vector(%d) = [", vec->length);
    for(int i = 0; i < vec->length; i++) {
        i && printf(", ");
        printf("%d",vec->data[i]);

    }
    printf("]\n");
    return;
}

void clear(Vector *vec) {
    if(vec == NULL) return;
    free(vec->data);
    free(vec);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, ind, val;
    Vector *vec = init(max_op);
    for(int i = 0; i < max_op; i++) {
        op = rand() % 4;
        ind = rand() % (vec->length + 3) - 1;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2:{
                printf("insert %d at %d to Vector = %d\n",val, ind, insert(vec, ind, val));
            }break;
            case 3:{
                printf("earse item at %d from Vector = %d\n", ind, erase(vec, ind));
            }break;
        }
            output(vec);
            printf("\n");
    }
    clear(vec);
    return 0;
}
```



## 2.链表

 ![2020-02-11 18-17-34屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzcakdbpj30mn09pjsu.jpg)

##### 程序内部，内存内部

指向head的指针，体现在内存内部，内存内部节点信息，内存内部（数据域，指针域）

![undefined](http://ww1.sinaimg.cn/large/006Uqzbtly1gewz87gzujj30m9094acj.jpg)

在单向循环链表中之所以把head看做整个单向循环链表的尾戒点，解决了插入在１号的前面走一圈的问题。

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct ListNode {
    int data;
    struct ListNode *next;
}ListNode;

typedef struct List {
    ListNode head;
    int length;
}List;

ListNode *getNewNode(int val) {
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p->data = val;
    p->next = NULL;
    return p;
}

List *getLinkList() {
    List *l = (List *)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}

int insert(List *l,int ind, int val) {
    if(l == NULL) return 0;
    if(ind < 0 || ind > l->length) return 0;
    ListNode *p = &(l->head), *node = getNewNode(val);
    while(ind--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return 1;
}

int erase(List *l, int ind) {
    if(l == NULL) return 0;
    if(ind < 0 || ind >= l->length) return 0;
    ListNode *p = &(l->head), *q;
    while(ind--) p = p->next;
    q = p->next;
    p->next = q->next;
    free(q);
    l->length--;
    return 1;
}
void output(List *l) {
    printf("List(%d) = [", l->length);
    for(ListNode *p = l->head.next; p; p=p->next ) {
        printf("%d->", p->data);
    } 
    printf("NULL]\n");
    return ;
}

void clear_ListNode(ListNode *node) {
    if(node == NULL) return;
    free(node);
    return;
}

void clear_list(List *l) {
    if(l == NULL) return;
    ListNode *p = l->head.next, *q;
    while(p) {
        q = p->next;
        clear_ListNode(p);
        p = q;
    }
    free(l);
    return;
}


int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    int op, ind, val;
    for(int i = 0; i < max_op; i++) {
    op = rand() % 4;
    ind = rand() % (l->length + 3) - 1;
    val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf("insert %d at %d to list = %d\n", val, ind, insert(l, ind, val));
            } break;
            case 3: {
                printf("earse item at %d from list = %d\n", ind, erase(l, ind));
            }break;
        }
        output(l);
        printf("\n");
    }
    clear_list(l);
return 0;
}
```



##### 链表翻转：

![2020-02-11 20-35-45屏幕截图.png](https://i.loli.net/2020/05/18/jPeCUNyAz91bH2Q.png)
![2020-02-11 20-36-51屏幕截图.png](https://i.loli.net/2020/05/18/uN7JrBvYaW4hAiq.png)



```cpp
void reverse(List *l) {
    if(l == NULL) return;
    ListNode *p = l->head.next, *q;
    l->head.next = NULL;
    while(p) {
        q = p->next;
        p->next = l->head.next;
        l->head.next = p;
        p = q;
    }
    return ;
}
```



最终代码：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct ListNode {
    int data;
    struct ListNode *next;
}ListNode;

typedef struct List {
    ListNode head;
    int length;
}List;

ListNode *getNewNode(int val) { //初始化获取一个新的节点
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p->data = val;
    p->next = NULL;
    return p;
}

List *getLinkList() { //初始化一个链表
    List *l = (List *)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}

int insert(List *l,int ind, int val) {　//插入
    if(l == NULL) return 0;
    if(ind < 0 || ind > l->length) return 0;
    ListNode *p = &(l->head), *node = getNewNode(val);
    while(ind--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return 1;
}

int erase(List *l, int ind) {　//删除
    if(l == NULL) return 0;
    if(ind < 0 || ind >= l->length) return 0;
    ListNode *p = &(l->head), *q;
    while(ind--) p = p->next;
    q = p->next;
    p->next = q->next;
    free(q);
    l->length--;
    return 1;
}


void output(List *l) {　//输出
    printf("List(%d) = [", l->length);
    for(ListNode *p = l->head.next; p; p=p->next ) {
        printf("%d->", p->data);
    } 
    printf("NULL]\n");
    return ;
}

void reverse(List *l) {　// 翻转
    if(l == NULL) return;
    ListNode *p = l->head.next, *q;
    l->head.next = NULL;
    while(p) {
        q = p->next;
        p->next = l->head.next;
        l->head.next = p;
        p = q;
    }
    return ;
}



void clear_ListNode(ListNode *node) {
    if(node == NULL) return;
    free(node);
    return;
}

void clear_list(List *l) {
    if(l == NULL) return;
    ListNode *p = l->head.next, *q;
    while(p) {
        q = p->next;
        clear_ListNode(p);
        p = q;
    }
    free(l);
    return;
}


int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    int op, ind, val;
    for(int i = 0; i < max_op; i++) {
    op = rand() % 4;
    ind = rand() % (l->length + 3) - 1;
    val = rand() % 100;
        switch(op) {
            case 0:
            case 1: {
                printf("insert %d at %d to list = %d\n", val, ind, insert(l, ind, val));
            } break;
            case 2:{
                printf("reverse the list\n");
                reverse(l);
            }break;
            case 3: {
                printf("earse item at %d from list = %d\n", ind, erase(l, ind));
            }break;
        }
        output(l);
        printf("\n");
    }
    clear_list(l);
return 0;
}
```



拓展：（打印箭头）

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct ListNode {
    int data;
    struct ListNode *next;
}ListNode;

typedef struct List {
    ListNode head;
    int length;
}List;


ListNode *getNewNode(int val) {
    ListNode *p = (ListNode *)malloc(sizeof(ListNode));
    p->data = val;
    p->next = NULL;
    return p;
}

List *getLinkList() {
    List *l = (List *)malloc(sizeof(List));
    l->head.next = NULL;
    l->length = 0;
    return l;
}



int insert(List *l,int ind, int val) {
    if(l == NULL) return -1;
    if(ind < 0 || ind > l->length) return -1;
    int ret = ind;
    ListNode *p = &(l->head), *node = getNewNode(val);
    while(ind--) p = p->next;
    node->next = p->next;
    p->next = node;
    l->length++;
    return ret;
}

int erase(List *l, int ind) {
    if(l == NULL) return -1;
    if(ind < 0 || ind >= l->length) return -1;
    int ret = ind;
    ListNode *p = &(l->head), *q;
    while(ind--) p = p->next;
    q = p->next;
    p->next = q->next;
    free(q);
    l->length--;
    return ret;
}

void output_search(List *l, int ind) {
    char str[100];
    int offset = 3;
    ListNode *p = l->head.next;
    while(ind != -1 && p) {
        offset += sprintf(str, "%d->", p->data);
        ind -= 1;
        p = p->next;
    }
    for(int i = 0; i < offset; i++) printf(" ");
    printf("^\n");
    for(int i = 0; i < offset; i++) printf(" ");
    printf("|\n\n");
    return;
}

void output(List *l) {
    printf("head->");
    for(ListNode *p = l->head.next; p; p=p->next ) {
        printf("%d->", p->data);
    } 
    printf("NULL\n");
    return ;
}


void clear_ListNode(ListNode *node) {
    if(node == NULL) return;
    free(node);
    return;
}

void clear_list(List *l) {
    if(l == NULL) return;
    ListNode *p = l->head.next, *q;
    while(p) {
        q = p->next;
        clear_ListNode(p);
        p = q;
    }
    free(l);
    return;
}



int main() {
    srand(time(0));
    #define max_op 20
    List *l = getLinkList();
    int op, ind, val, flag;
    for(int i = 0; i < max_op; i++) {
    op = rand() % 4;
    ind = rand() % (l->length + 3) - 1;
    val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf("insert %d at %d to list\n", val, ind);
                flag = insert(l, ind, val);
            } break;
            case 3: {
                printf("earse item at %d from list \n", ind);
                flag = erase(l, ind);
            }break;
        }
        output(l);
        output_search(l, flag);
        printf("\n");
    }
    clear_list(l);
return 0;
}

```

![2020-02-11 18-42-49屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzqv1xtjj30cq044757.jpg)

##　3.队列&栈

#### **（１）队列：**先进先出

![2020-02-13 16-10-53屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzrfse7nj30hf0afdgx.jpg)



![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tbsaj30hi0ad765.jpg)

![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tbn5j30ip0agtap.jpg)

队列假溢出：

![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5tklcj30m50adtb4.jpg)

1,2,3空间扔在，而当前插入不下，即为假溢出，有空间能插入；

如果队尾能指向第一个元素，则引入循环队列     －>

![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzs5u7u9j30md0ayjt4.jpg)

![循环队列.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzubk23uj30mv0b0juc.jpg)

主要思考　头２　尾３　元素个数４

####  **（２）栈　**：后进先出

![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzv0d83hj30ny0agmyf.jpg)

![](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzw8zszsj30le0b2jt4.jpg)

![出栈.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzxd1077j30kd0a4abn.jpg)

#####  **循环队列：**

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

typedef struct Queue {
    int *data;
    int head, tail, size, count;　// count 记录有几个数，
}Queue;

Queue *init(int n) {　// 初始化一个队列
    Queue *q = (Queue *)malloc(sizeof(Queue));
    q->data =(int *) malloc(sizeof(int) * n);
    q->head = q->tail = q->count = 0;　// 初始化为head = tail = count = 0;
    q->size = n; // 容量
    return q;
}

int empty(Queue *q) {　// 判空
    return q->count == 0;
}

int front(Queue *q) {　//返回队首部
    return q->data[q->head];　
}

int push(Queue *q, int val) {　// 进队
    if(q == NULL) return 0;
    if(q->count == q->size) return 0; 
    q->data[q->tail++] = val; 
    if(q->tail == q->size)q->tail -= q->size;
    q->count ++;
    return 1;
}

int pop(Queue *q) {　// 删除
    if(q == NULL) return 0;
    if(empty(q))return 0;
    q->head ++;
    if(q->head == q->size) q->head -= q->size;
    q->count --;
    return 1;
}

void output(Queue *q) {　
    printf("Queue(%d) = [", q->count);
    for(int i = q->head, j = 0; j < q->count; j++) {
        j && printf(", ");
        printf("%d", q->data[(i + j) % q->size]); // 输出的时候从i = head 往后循环
    }
    printf("]\n");
    return ;
}

void clear(Queue *q) { //用到的
    if(q == NULL) return ;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, val;
    Queue *q = init(max_op);
    for(int i = 0; i < 2 * max_op; i++) {
        op = rand() % 4;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2: {
                printf("push %d to Queue = %d\n", val, push(q, val));
            }break;
            case 3: {
                printf("pop %d from Queue = ", front(q));
                printf("%d\n", pop(q));
            }break;
        }
        output(q);
        printf("\n");
    }
    return 0;
}

```

#####　循环队列的扩容：

（相当于顺序表的扩容）

```cpp
int expand(Queue *q) {
    int extr_size = q->size;
    int *p;
    while(extr_size) {
        p = (int *)malloc(sizeof(int) * (q->size + extr_size));
        if(p)break;
        extr_size /= 2;
    }
    if(p == NULL) return 0;
    for(int i = q->head, j = 0; j < q->count ; j++) { // 全部拷贝过来
       p[j] = q->data[(i + j) % q->size];
    }
    q->size += extr_size;　//再次初始化
    q->head = 0;
    q->tail = q->count;
    free(q->data);　// 释放
    q->data = p;
    return 1;
}
```

realloc只是将原来数据直接放在那个上面，malloc不同

##### **栈：**

```cpp

#include<stdio.h>
#include<stdlib.h>
#include<time.h>

typedef struct Stack{
    int *data;
    int top, size;
}Stack;

Stack *init(int n) {
    Stack *s = (Stack *) malloc(sizeof(Stack));
    s->data = (int *)malloc(sizeof(int) * n);
    s->top = -1;
    s->size = n;
    return s;
}

int empty(Stack *s) {
    return s->top == -1;
}

int top(Stack *s) {
    return s->data[s->top];
}

int push(Stack *s, int val) {
    if(s == NULL) return 0;
    if(s->top + 1 == s->size) return 0;
    s->data[++(s->top)] = val;
    return 1;
}

int pop(Stack *s) {
    if(s == NULL) return 0;
    if(empty(s))return 0;
    s->top -= 1;
    return 1;
}

void output(Stack *s) {
    printf("Stack(%d) = [", s->top + 1);
    for(int i = 0; i <= s->top; i++) {
        i && printf(", ");
        printf("%d", s->data[i]);
    }
    printf("]\n");
    return;
}

void clear(Stack *s) {
    if(s == NULL) return ;
    free(s->data);
    free(s);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    int op, val;
    Stack *s = init(max_op);
    for(int i = 0; i < max_op; i++) {
        op = rand() % 4;
        val = rand() % 100;
        switch(op) {
            case 0:
            case 1:
            case 2:{
                printf("push %d to Stack = %d\n", val, push(s, val));
            } break;
            case 3:{
                printf("pop %d from Stack = ", top(s));
                printf("%d\n", pop(s));
            }break;
        }
        output(s);
        printf("\n");
    }
    clear(s);
    return 0;
}

```



##### 栈的扩容：

（相当于顺序表的扩容）

```cpp
int expand(Stack *s) {
    int extr_size = s->size;　// 先记录一下s->size;
    int *p; 
    while(extr_size) { // 直至扩容到结束
        p = (int *) realloc(s->data, sizeof(int) * (s->size + extr_size));
        if(p) break;　// 如果ｐ为０时，继续循环（因为realloc开辟失败时返回值为０）
        extr_size /= 2;
    }
    if(p == NULL) return 0; // 开辟失败时结束
    s->size += extr_size; 
    s->data = p; 
    return 1;
}
```

#####　系统栈求表达式结果：

```cpp
#include<stdio.h>
#include<math.h>
#include<inttypes.h>
#include<string.h>
#define max_n  100

int calc(const char *str, int l, int r) {
    int prior = 0x3f3f3f3f - 1, temp = 0, pos = -1;
    for(int i = l; i <= r; i++) {/*找到优先级最低的位置*/
        int cur_prior = 0x3f3f3f3f;
        switch(str[i]) {
            case '(': temp += 100; break;
            case ')': temp -= 100; break;
            case '+':
            case '-': cur_prior = temp + 1; break;
            case '*':
            case '/': cur_prior = temp + 2; break;
            case '^': cur_prior = temp + 3; break;
        }
        if(cur_prior <= prior) {
            prior = cur_prior;
            pos = i;
        }
    }
    if(pos == -1){
        int num = 0;
        for(int i = l; i <= r; i++) {
            if(str[i] < '0' || str[i] >'9')continue;
            num = num * 10 + str[i] -'0';
        }
        return num;
    }
    int a = calc(str, l , pos - 1);
    int b = calc(str, pos + 1, r);
    switch(str[pos]) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
        case '^': return (int)pow(a, b);
    }
    return 0;
}


int main() {
    char str[max_n + 5] = {0};
    while(scanf("%[^\n]s", str) != EOF) {
        getchar();
        printf("%d\n", calc(str, 0, strlen(str) - 1));
    }
    return 0;
}
```







![2020-02-13 20-55-36屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzz7l8qsj30cq041dge.jpg)

## 4.树与二叉树

完全包含的数据结构：栈<＝>树

##### 树的结构定义

```cpp
typedef struct Node {
    int data;
    struct Node *next; // 有很多指针指向struct Node *next[3]三个指向
}Node, *LinkedList;
```
１．树的深度高度相同
２．节点的深度为根到结点，高度从此处往下看；
３．结点数量等于边数加１
４．树转化为二叉树：（左孩子右兄弟）＝【十字链表法】


##### 二叉树的存储
１．每个节点度最多为２
２．度为０的节点比度为２的节点多１个

>因为n1 + n0 + n2 = n1 + 0 + 2 * n2 + 1
>所以n2 + 1 = n0

３．N叉树，N个指针指向
４．因为无论一个怎样的N叉树都能转化为一个二叉树，所以二叉树更有意义；N叉树不确定，性二叉树确定性。
５．完全二叉树：（１）编号为ｉ左孩子编号为*2×i,*右孩子*2×i+1*，（２）可以用连续空间存储|数组|；
６．<font color = red>广义表</font>　－－　根（左，右）

![img](http://res.jisuanke.com/img/upload/20160406/2c589a6c7026a90dc27975acd63702ebaf1a35d0.png)

```cpp
typedef struct Node {//二叉树结点的结构体 Node
    int data; 
    struct Node *lchild, *rchild; // 左-右孩子
} Node;
```

**初始化**

```cpp
Node* init(int data) { //初始化函数 init
    Node *node =(Node *)malloc(sizeof(Node));
    node->data = data;
    node->lchild = NULL;
    node->rchild = NULL;
    return node;
}
```

**清空释放**

```cpp
void clear(Node *node) {
    if (node->lchild != NULL) {
        clear(node->lchild); // 采用递归释放
    }
    if (node->rchild != NULL) {
        clear(node->rchild);
    }
    free(node);
}
```

**建立函数 build_demo**

```cpp
Node * build_demo(){
    Node *node = init(1); // 通过init()进行建立关系
    node->lchild = init( 2);
    node->rchild = init(3);
    node->lchild->lchild = init(4);
    node->lchild->rchild = init(5);
    node->rchild->rchild = init(6);
    return node;
}
```



##### 二叉树的遍历
###### 先序遍历

从根节点开始，先访问当前节点，如果左边子树不为空，则继续访问左子树，之后若右子树不为空再访问右子树，进行遍历；(根->左->右)

![img](https://res.jisuanke.com/img/upload/20161108/59c39c81ee495f030b8bae1fd80b6f6b7f715f19.gif)

如图Ｌ访问结束后在访问Ｙ

![img](https://res.jisuanke.com/img/upload/20161108/effe9371c61337852a033ef5b89da26ab35ec356.gif)

按照这样接着遍历ｗ的右子树,遍历完之后回溯到Ｍ，最后把M的右子树遍历完。

```cpp
void preorder(Node *node) {
    printf("%d ", node->data);//把当前节点的数据域输出
    if(node->lchild!= NULL) { //如果左子树不为空，递归调用其函数preorder
        preorder(node->lchild);
    }
    if(node->rchild != NULL) { //同理访问右子数
        preorder(node->rchild);
    }
}
```

###### 中序遍历

中序遍历是从当前的左子树开始遍历，再访问当前节点最后访问右子树（左->根->右）

![img](https://res.jisuanke.com/img/upload/20161108/c2da0f438ca7a8a5b5968ee75727a4d17b6fd459.gif)

向左访问直到Ｗ，然后继续访问中Ｇ然后访问Ｌ

![img](https://res.jisuanke.com/img/upload/20161108/60d71ed22aeed22c3f4b4e45f15dfa8956cde880.gif)

回溯待Ｖ输出，继续访问其右子树；



```cpp
void inorder(Node *node) {
    if(node->lchild != NULL) { //先访问左子树不为空，递归调用
        inorder(node->lchild);
    }
    printf("%d ", node->data);　// 访问完左子树访问当前节点
    if(node->rchild!=NULL) {　// 最后递归访问右子树
        inorder(node->rchild);
    }
}
```

###### 后序遍历

后序遍历是从当前的左子树开始遍历，再访问右节点最后访问当前节点（左->右->根）

<img src="https://res.jisuanke.com/img/upload/20161108/231b93e962bec9efcc4fb76e939d7478388bf774.gif" alt="img" style="zoom: 67%;" />

```cpp
void postorder(Node *node) {
    if(node->lchild != NULL) { //先访问左子树不为空，递归调用
        postorder(node->lchild);
    }
    if(node->rchild != NULL) { //再访问右子树不为空。递归
        postorder(node->rchild);
    }
    printf("%d ", node->data);
}
```

###### 已知先序和中序求后序

参数：`pre_str[],  in_str[],  len`分别为先序、中序、遍历中序遍历的个数。

思路：我们先获取根节点在先序中的编号，在中序遍历中我们找到根节点的所在位置，那么位置前面的结点就是左子树上的结点，位置后面的就是根节点右子树上的结点。然后递归建立二叉树；

```cpp
// 建立二叉树的函数 build
Node *build(char pre_str[], char in_str[], int len) {
    Node *p = init(pre_str[0] - '0');
    int pos = strchr(in_str, pre_str[0]) - in_str;
    if(pos > 0) {
        p->lchild = build(pre_str + 1, in_str, pos);　// 1 ~ pos
    }
    if(len - pos - 1 > 0) {
        p->rchild = build(pre_str + pos + 1, in_str + pos + 1, len - pos - 1); // pos + 1 ~ len - pos - 1
    } 
    return p;
}
```

![2020-02-15 15-35-04屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gewzzmjkanj30cw04xjso.jpg)


##### 二叉树的线索化
主要是为了解决８ＭＢ系统栈的爆。
１．左空指前驱，右空指向后继（中序遍历前提）；
２．ｌｔａｇ前驱，ｒｔａｇ后继（区分左右孩子）
３．优点：
(1)利用线索二叉树进行中序遍历时，不必采用堆栈处理，速度较一般二叉树的遍历速度快，且节约存储空间。
(2)任意一个结点都能直接找到它的前驱和后继结点。
４．<font color = red>一个结点的前驱是左子树最右边的结点，后继是右子树的最左结点。</font>

![build_thread.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex003sq2fj30h00avdgy.jpg)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

#define NORMAL 0
#define THREAD 1

typedef struct Node{
    int data;
    struct Node *lchild, *rchild;
    int ltag, rtag;
}Node;

Node*getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    p->ltag = NORMAL;
    p->rtag = NORMAL;
    return p;
}
Node *insert(Node *root, int val) {
    if(root == NULL) return getNewNode(val);
    if(root->data == val)return root;
    if(val < root->data) root->lchild = insert(root->lchild, val);
    else root->rchild = insert(root->rchild, val);
    return root;
}

void build_thread(Node *root) { // 1 -> 2-> 4,
    if(root == NULL) return ;
    static Node *pre = NULL; 
    build_thread(root->lchild); // 先建立左子树
    if(root->lchild == NULL) {　// 走到最左边为空时
        root->lchild = pre;　// 4 ->NULL
        root->ltag = THREAD;  // 标记已经线索化
    }
    if(pre != NULL && pre->rchild == NULL) {　// 4回溯为２，此处构造为４->root (2)
        pre->rchild = root;
        pre->rtag = THREAD;
    }
    pre = root; // 此时pre 为4处的ｒｏｏｔ
    build_thread(root->rchild);　// 继续构造右边的子树
    return ;
}

Node *most_left(Node *p) {
    while(p&&p->ltag == NORMAL && p->lchild != NULL) p=p->lchild;　// p一直往左走
    return p;
}

void output(Node *root) {
    Node *p = most_left(root);　// 先走到最走边结点４
    while(p) {　// p不为空不挑出
        printf("%d ", p->data);　
        if(p->rtag == THREAD) { // 如果存在右边线索往右走
            p = p->rchild;
        } else {　　//不存在的话往右子树的最左子树
            p = most_left(p->rchild);
        }
    }
    return ;
}

void in_order(Node *root) {
    if(root == NULL) return;
    if(root->ltag == NORMAL)in_order(root->lchild);
    printf("%d ", root->data);
    if(root->rtag == NORMAL) in_order(root->rchild);
    return;
}



void clear(Node *root) {
    if(root == NULL) return;
    if(root->ltag == NORMAL) clear(root->lchild);
    if(root->rtag == NORMAL)clear(root->rchild);
    free(root);
    return;
}

int main() {
    srand(time(0));
    #define max_op 20
    Node *root = NULL;
    for(int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        root = insert(root, val);
    }
    build_thread(root);
    output(root);
    printf("\n");
    in_order(root);
    printf("\n");
    clear(root);
    return 0;
}
```

##### 二叉树转广义表

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
typedef struct Node{
    int data;
    struct Node *lchild, *rchild;
}Node;
typedef struct Tree {
    Node *root;
    int n;
}Tree;

Node *getNewNode(int val) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = NULL;
    p->rchild = NULL;
    return p;
}
Tree *getNewTree() {
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}


Node *insertNode(Node *root, int val, int *ret) {
    if(root == NULL){ /*插入成功*/
        *ret = 1;
        return getNewNode(val);
    }
    if(root->data == val) return root; // 插入失败
    if(val < root->data) root->lchild = insertNode(root->lchild,val, ret);
    else root->rchild = insertNode(root->rchild, val, ret);
    return root;
}

void insert(Tree *tree, int val) {
    int flag = 0;
    tree->root = insertNode(tree->root, val, &flag);
    tree->n += flag; // 不知道插入成功还是失败
    return;
}

void outputNode(Node *root) {
    if(root == NULL) return;
    printf("%d", root->data);
    if(root->lchild == NULL && root->rchild == NULL) return;
    printf("(");
    outputNode(root->lchild);
    printf(",");
    outputNode(root->rchild);
    printf(")");
    return;
}
void output(Tree *tree) {
    printf("Tree(%d) = ", tree->n);
    outputNode(tree->root);
    printf("\n");
    return;
}

/*前序遍历*/
void pre_orderNode(Node *root) {
    if(root == NULL) return;
    printf("%d ", root->data);
    pre_orderNode(root->lchild);
    pre_orderNode(root->rchild);
    return;
}


void preorder(Tree *tree) {
    printf("pre_order :");
    pre_orderNode(tree->root);
    printf("\n");
    return;
}

/*中序遍历*/
void in_orderNode(Node *root) {
    if(root == NULL) return;
    in_orderNode(root->lchild);
    printf("%d ", root->data);
    in_orderNode(root->rchild);
    return;
}


void inorder(Tree *tree) {
    printf("in_order :");
    in_orderNode(tree->root);
    printf("\n");
    return;
}

/*后序遍历*/
void post_orderNode(Node *root) {
    if(root == NULL) return;
    post_orderNode(root->lchild);
    post_orderNode(root->rchild);
    printf("%d ", root->data);
    return;
}


void postorder(Tree *tree) {
    printf("post_order :");
    post_orderNode(tree->root);
    printf("\n");
    return;
}


void clear_Node(Node *node) {
    if(node == NULL) return;
    clear_Node(node->lchild);
    clear_Node(node->rchild);
    return ;
}
void clear_Tree(Tree *tree) {
    if(tree == NULL) return;
    clear_Node(tree->root);
    free(tree);
    return;
}

int main() {
    srand(time(0));
    #define max_op 10
    Tree *tree = getNewTree();
    for(int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        insert(tree, val);
        output(tree);
        printf("\n");
    }
    preorder(tree);
    inorder(tree);
    postorder(tree);
    clear_Tree(tree);
    return 0;
}

```

##### 广义表转二叉树
１.字符　２．左括号　３．逗号　４．右括号

![2020-02-15 20-29-43屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex01sc0njj31hc0u0dqo.jpg)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
typedef struct Node {
    char data;
    struct Node *lchild, *rchild;
}Node;

typedef struct Tree {
    Node *root;
    int n;
}Tree;

typedef struct Stack {
    Node **data; /*Stack此处应该是Node *类型*/
    int top, size;
} Stack;


Node *getNewNode(char val) { /* 获取一个新的结点*/
    Node *p = (Node *)malloc(sizeof(Node));
    p->data = val;
    p->lchild = p->rchild = NULL;
    return p;
}

Tree *getNewTree() {  
    /* 获取一个新的树*/
    Tree *tree = (Tree *)malloc(sizeof(Tree));
    tree->root = NULL;
    tree->n = 0;
    return tree;
}

Stack *init_stack(int n){ //初始化一个栈
    Stack *s = (Stack *)malloc(sizeof(Stack));
    s->data = (Node **)malloc(sizeof(Node *) * n); // 开辟数据的长度为ｎ的大小个，结点类型的
    s->top = -1;// 初始化栈顶都为-１
    s->size = n;
    return s;
}

int empty(Stack *s) { //判断一个栈是否为空
    return s->top == -1; 
}

Node *top(Stack *s) {// 返回栈顶元素，返回类型为Node *类型，为结点类型
    return s->data[s->top];
}

int push(Stack *s, Node *val) { // 结点入栈操作,此处为Node *val
    if(s == NULL) return 0;
    if(s->top == s->size - 1) return 0;
    s->data[++(s->top)] = val;
    return 1;
}

int pop(Stack *s) { //删除栈顶操作
    if(empty(s)) return 0;
    s->top -= 1;
    return 1;
}
void clear_stack(Stack *s); 
Node *build(char *str, int *node_num) { //建立二叉树，由广义表转二叉树
    Node *temp = NULL, *p = NULL; //定义两个结点
    Stack *s = init_stack(strlen(str));// 初始化一个栈大小为字符串长度
    int flag = 0; //标记，如果遇到“，”则为１，告诉下面是左还是右子树
    while(str[0]) {
        switch(str[0]) { //如果不是\n继续往后遍历
            case '(' :   
                   push(s, temp);//如果遇到（将入栈
                   flag = 0;
                   temp = NULL;//将temp置空
                   break;
            case ')' :
                   p = top(s); //如果遇到）时出栈
                   pop(s);
                   break;
            case ',' :
                   flag = 1; //遇到“，”标记，将temp＝ＮＵＬＬ；
                   temp = NULL; //告诉下面右子树为空
                   break;
            case ' ' :
                   break;
            default  : // 如果是字母
                   temp = getNewNode(str[0]);//获取一个节点
                   if(!empty(s)&& flag == 0){ //如果栈不为空，并且为左子树
                   top(s) ->lchild = temp; 
                   } else if(!empty(s)&&flag == 1) { //如果栈不为空，并且为右子树，
                   top(s) ->rchild = temp;
                   }
                   ++(*node_num);//创建一个成功后记录个数
            break;
        }
        ++str; // str往后移动
    }
    clear_stack(s); //清空栈
    if(temp && !p) p = temp;// temp 不为空，p为空,将p = temp;
    return p; //返回p，p为顶
}

/*中序遍历*/
void in_orderNode(Node *node) {
    if(node == NULL) return;
    in_orderNode(node->lchild);
    printf("%c ", node->data);
    in_orderNode(node->rchild);
    return;
}

void in_order(Tree *tree) {
    printf("in_order : ");
    in_orderNode(tree->root);
    return;
}
/*前序遍历*/
void pre_orderNode(Node *node) {
    if(node == NULL) return;
    printf("%c ", node->data);
    pre_orderNode(node->lchild);
    pre_orderNode(node->rchild);
    return;
}

void pre_order(Tree *tree) {
    printf("pre_order : ");
    pre_orderNode(tree->root);
    return;
}
/*后序遍历*/
void post_orderNode(Node *node) {
    if(node == NULL) return;
    post_orderNode(node->lchild);
    post_orderNode(node->rchild);
    printf("%c ",node->data);
    return;
}

void post_order(Tree *tree) {
    printf("post_order : ");
    post_orderNode(tree->root);
    return;
}




void clear_node(Node *node) {
    if(node == NULL) return ;
    clear_node(node->lchild);
    clear_node(node->rchild);
    return;
}


void clear_tree(Tree *tree) {
    if(tree == NULL) return;
    clear_node(tree->root);
    free(tree);
    return ;
}

void clear_stack(Stack *s) {
    if(s == NULL) return ;
    free(s->data);
    free(s);
    return;
}

int main() {
    char str[100];
    scanf("%[^\n]s", str);
    int node_num = 0;
    Tree *tree = getNewTree();
    tree->root = build(str, &node_num);
    tree->n = node_num;
    pre_order(tree), printf("\n");
    in_order(tree), printf("\n");
    post_order(tree), printf("\n");
    clear_tree(tree);
    return 0;
}
```



## ５.堆与优先队列

**完全二叉树:**

![2020-02-18 15-40-26屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex02kazyqj30mb076wfr.jpg)

一个根结点root它左孩子root * 2 + 1, 右孩子root * 2 + 2
那么一个孩子求父节点为(lchild  - 1) / 2, (rchild - 1) / 2

##### **堆：**
大顶堆：当前任意一个根节点大于其两个孩子（最大值放在根）
小顶堆：当前任意一个根节点小于其两个孩子（最小值放在根）

*结构操作：*
插入：
　　插入在尾部--调整为了保持堆序性，接下来我们要通过比较元素的父结点权值，做从小到大的堆调整。如果元素比父结点权值大，则将元素与其父结点进行交换。如果还比此时的父结点权值大，则继续调整，否则结束调整操作。
![2020-02-18 15-52-15屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex02xx7yej30m708kgnk.jpg)调整的时候不断向上调整直至满足大顶堆。

输出堆顶：
　　先拿出堆顶h->data[0]，然后让最后一个值覆盖，调整的时候不断向下调整直至满足大顶堆。

##### **优先队列**

优先队列内部一般是用堆来实现的。我们知道堆的插入、删除操作的时间复杂度都是 O(log*N*)，自然优先队列的插入、删除操作的时间复杂度也都O(log*N*)。堆中的堆顶元素就是优先队列的队首元素。
![2020-02-18 16-14-30屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex036mf58j30hr09imyo.jpg)

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b, b = __temp;\
}
typedef struct priority_queue{ //结构定义优先队列
    int *data;
    int cnt, size; 
}priority_queue;

priority_queue *init(int n) {　//获取一个队列
    priority_queue *q = (priority_queue *)malloc(sizeof(priority_queue));
    q->data = (int *)malloc(sizeof(int) * ( n + 1 ));
    q->cnt = 0;
    q->size = n;
    return q;
}

int empty(priority_queue *q) {
    return q->cnt == 0;
}

int top(priority_queue *q) {
    return q->data[1];
}

int push(priority_queue *q, int val) {　// 插入
    if(q == NULL) return 0;
    if(q->cnt == q->size)return 0;
    q->cnt += 1;//先往后移动一下
    q->data[q->cnt] = val;// 将值插入
    int ind = q->cnt; //初始ｉｎｄ= 末尾
    while(ind >> 1 && q->data[ind] > q->data[ind >> 1]) {//如果此时根节点小于子节点
        swap(q->data[ind], q->data[ind >> 1]);//交换
        ind >>= 1;//继续／２，相当于根节点继续往上走
    }
    return 1;
}
int pop(priority_queue *q) {　
    if(q == NULL)  return 0;
    if(empty(q)) return 0;
    q->data[1] = q->data[q->cnt--];//先将最后一位覆盖第一位，总数减一
    int ind = 1;
    while((ind << 1) <= q->cnt ) {//如果子节点不超过最后一位
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if(q->data[l] > q->data[temp]) temp = l; //如果左孩子大于最大结点将它付给最大节点
        if(r <= q->cnt && q->data[r] > q->data[temp])temp = r;//将右边孩子与最大节点相比较，找出最大节点
        if(temp == ind)break; //如果没有找到
        swap(q->data[ind], q->data[temp]);
        ind = temp;
    }
    return 1;
}


void clear(priority_queue *q) {
    if(q == NULL) return;
    free(q->data);
    free(q);
    return ;
}

int main() {
    srand(time(0));
    #define max_op 20
    priority_queue *q = init(max_op);
    for(int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        push(q, val);
        printf("insert %d to queue\n", val);
    }
    for(int i = 0; i < max_op; i++) {
        printf("%d ", top(q));
        pop(q);
    }
    printf("\n");
    clear(q);
    return 0;
}
```



##### 堆排序：

１．将对顶元素与堆尾部交换
２．将此操作看做对顶元素弹出操作
３．按照头部弹出后策略调整

首先我们得到一个大根堆，然后从堆的最后一个元素开始，依次往前遍历，每次首先将堆顶元素和当前元素进行交换，交换后再对新的堆顶做一个自上而下的堆调整。堆排序和选择排序有些类似，每次选一个最大值和当前元素交换，只不过这里是利用堆来维护，调整效率比选择排序高了很多，时间复杂度可以达到 O(log n)，要交换`n`次，调整`n`次，所以堆排序的时间复杂度为 O(*n*log*n*)。

自上而下自上而下:

子和父亲比只需要比一次就可以调整 ,不需要讲同层元素与父节点比较 , 由于是自底向上建立堆，因此在调整上层元素的时候，并不需要同下层所有元素做比较，只需要同其中之一分支作比较, 自上而下一层比两个，父节点和左子节点比一次，父节点和右子节点比一次，自下而上，只需要当前节点和父亲比就可以了 .

堆排序：

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

void downUpdate(int *arr, int n, int ind) { //自顶向下调整
    while((ind << 1) <= n) {
        int temp = ind, l = ind << 1, r = ind << 1 | 1;
        if(arr[l] > arr[temp]) temp = l;
        if(r <= n && arr[r] > arr[temp]) temp = r;
        if(temp == ind) break;
        swap(arr[temp], arr[ind]);
        ind = temp;
    }
    return;
}

void heap_sort(int *arr, int n) {
    arr -= 1;　// 因为传过来的arr值是从0开始的，我们想从１开始访问，那么必须地址往后移动一位；也就是原１的地址现在存原０值；
    for(int i = n >> 1; i >= 1; i--) {　// 从ｎ/2开始往前调整初建立堆
        downUpdate(arr, n, i);
    }
    for(int i = n; i > 1; i--) {　// 堆排序；
        swap(arr[i], arr[1]);
        downUpdate(arr, i - 1, 1);
    }
    return ;
}

void output(int *arr, int n) {
    printf("arr(%d) = [", n);
    for(int i = 0; i < n; i++) {
        printf(" %d", arr[i]);
    }
    printf("]\n");
    return ;
}

int main() {
    srand(time(0));
    #define max_op 21
    int *arr = (int *)malloc(sizeof(int) * max_op);
    for(int i = 0; i < max_op; i++) {
        int val = rand() % 100;
        arr[i] = val;
    }
    output(arr, max_op);
    heap_sort(arr, max_op);
    output(arr, max_op);
    free(arr);
    return 0;
}
```

![2020-02-18 16-15-39屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex03hibblj30cu02d0t8.jpg)



![2020-02-18 18-37-49屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex03t286hj30qk0hw0vz.jpg)

![2020-02-18 18-46-52屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex042bjkqj30qm0hrta6.jpg)

## ６.排序算法





**外部排序**指的是大文件的排序，即待排序的记录存储在[外存储器](https://baike.baidu.com/item/外存储器/1226993)上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。
例如归并排序
**内部排序**是指待排序列完全存放在内存中所进行的排序过程，适合不太大的元素序列。
排序是计算机程序设计中的一种重要操作，其功能是对一个[数据元素](https://baike.baidu.com/item/数据元素)集合或序列重新排列成一个按数据元素某个相知有序的序列。排序分为两类：内排序和外排序。
其中[快速排序](https://baike.baidu.com/item/快速排序)是排序方法中被认为是最好的方法。

##### 稳定排序

*稳定的意思是两个相同的值在排序后两者先后顺序不变即为稳定！*
稳定排序包括：**插入排序**，**冒泡排序**， **归并排序**

###### 插入排序
1.将数组分成已排序区和待排序区间
2.将已排序区后面的一个元素，向前插入到待排序区中
3.直到待排序区没有元素为止
![插入排序](http://res.jisuanke.com/img/upload/20160304/3eca19c223fd1d9bffaff6a240fbbac00c400b84.gif)
插入排序每次插入的时间复杂度为 O(n)，一共执行n−1 次，因此总体时间复杂度为 O(n^2)。在插入时查找插入位置的过程可以使用折半查找算法将查找位置的复杂度优化到 O(logn)，但因为还需要 O(n) 的时间复杂度来在顺序表上执行移动操作，所以总体时间复杂度依然是 O(n＾2)。

```cpp
void insert(int *num, int n) {
    for(int i = 1; i < n; i++) {
        for(int j = i; j > 0 && num[j] < num[j - 1]; j--) {
            swap(num[j], num[j - 1]);
        }
    }
    return;
}
```

######　冒泡排序
1.将数组分为已排序区和待排序区
2.从头到尾扫描待排序区，若前面元素比后面元素大，则交换
3.每一轮都会将待排序区中最大的放在已排序区的开头
4.直到待排序区没有元素为止
![冒泡排序](http://res.jisuanke.com/img/upload/20160304/044b7de55573d738ad71c7820f628a76df26d6c9.gif)
冒泡排序算法的基本思想为：假如待排序线性表的长度为`n`，从前往后两两比较相邻元素的关键字，若 `ai−1>ai`，则交换它们，直到线性表比较完成。每趟交换以后最后一个元素一定是最大的，不再参与下一趟交换。也就是对于第i趟交换，只需要比较到 `an−i` 即可。直到一趟比较内没有进行交换，算法结束。时间复杂度和插入排序一样，也为` O(n^2)`。
<font color = blue>优化</font>：标记交换

```cpp
void bubble_sort(int *num, int n) {
    int times;
    for(int i = 0; i < n - 1 && times; i++) {
        times = 0;
        for(int j = 0; j < n - i - 1; j++) {
            if(num[j] > num[j + 1]) {
                swap(num[j], num[j + 1]);
                times++;
            }
        }
    }
    return;
}
```

###### 归并排序

![归并排序](http://res.jisuanke.com/img/upload/20160303/012e9ba7cd5dcbc4f0ccb7caa185e4f9769d29ed.gif)
归并排序一共需要进行 `O(logn) `层归并操作，每层归并操作的总时间复杂度为 `O(n)`，因此总体的时间复杂度为<font color = red>` O(nlogn)`</font>。和其他排序有所不同，为了实现归并操作，每次合并都需要开辟额外的空间来临时保存合并后的排序结果，总共需要开辟 `n`个元素的空间，所以归并排序的空间复杂度为`O(n)`(*分治思想*)![2020-02-20 15-40-21屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex04eckwtj30iw06m40n.jpg)
<font color = red>类似二叉树的后序遍历</font>

```cpp
void merge_sort(int *num, int l, int r) {
    if(r - l <= 1) {
        if(r - l == 1 && num[l] > num[r]) {
            swap(num[l], num[r]);
        }
        return;
    }
    int mid = (l + r) >> 1;
    merge_sort(num, l, mid);
    merge_sort(num, mid + 1, r);
    int *temp = (int *)malloc(sizeof(int)*(r - l + 1));
    int p1 = l, p2 = mid + 1, k = 0;
    while(p1 <= mid||p2 <= r) {
        if(p2 > r || (p1 <= mid && num[p1] <= num[p2])) {
            temp[k++] = num[p1++];
        } else {
            temp[k++] = num[p2++];
        }
    }
    memcpy(num + l, temp, sizeof(int) * (r - l + 1));
    free(temp);
    return;
}
```

##### 不稳定排序
不稳定排序有**选择排序**　**快速排序**

###### 选择排序
1.将数组分为已排序区和待排序区
2.每一轮从待排序区选择一个最小的元素放在已排序区的尾部
3.直到待排序区没有元素
![选择排序](http://res.jisuanke.com/img/upload/20160304/9c965158bc6178ef603ade226071fabb9a624a67.gif)
因为每趟可以让待排序区域的元素数量减少一个，所以总共需要 `n−1` 趟操作就可以将整个线性表排序完成。很显然，选择排序的时间复杂度也是 `O(n^2)`。
在每次查找关键字最小的元素时，可以使用堆对效率进行优化，使用堆来优化的选择排序就是堆排序。由于一共要查找 `n` 次最小值，每次查找的时间为 `O(logn)`，所以堆排序的时间复杂度为 `O(nlogn)`。

```cpp
void select_sort(int *num, int n) {
    for(int i = 0; i < n - 1; i++) {
        int ind = i;
        for(int j = i + 1; j < n; j++) {
            if(num[ind] > num[j]) ind = j;
        }
        swap(num[ind], num[i]);
    }
    return;
}
```





######　快速排序

![快速排序](http://res.jisuanke.com/img/upload/20160304/7a3c9a32f9e675cab345ef47dcd9c0db087105f8.gif)

快速排序是目前应用最广泛的排序算法之一。它的基本思想是，每次从待排序区间选取一个元素（我们在后面的课程中都是选取第一个）作为基准记录，所有比基准记录小的元素都在基准记录的左边，而所有比基准记录大的元素都在基准记录的右边。之后分别对基准记录的左边和右边两个区间进行快速排序，直至将整个线性表排序完成。
快速排序的时间复杂度不是稳定的，可以证明快速排序的平均时间复杂度为 `O(nlogn)`，最坏情况为` O(n^2)`，可以通过随机选择基准记录来尽可能避免最坏情况的出现。

```cpp
void quick_sort(int *num, int l, int r) {
    if(r < l) return;
    int x = l, y = r, z = num[l];
    while(x < y) {
        while(x < y && num[y] >= z) y--;
        if(x < y)num[x++] = num[y];
        while(x < y && num[x] <= z) x++;
        if(x < y)num[y--] = num[x];
    }
    num[x] = z;
    quick_sort(num, l, x - 1);
    quick_sort(num, x + 1, r);
    return;
}
```
优化：
```cpp
void quick_sort(int *num, int l, int r) {
    if(l >= r) return;
    int i = l - 1, r = r + 1, x = num[(l + r) >> 1];
    while(i < j) {
        do i++; while(num[i] < x);
        do j --; while(num[j] > x);
        if(i < j) {
            swap(num[i], num[j]);
        }
    }
    quick_sort(q, l, j), quick(q, j + 1, r);
}
```


##　７.查找

##### 二分查找
![2020-02-20 19-53-09屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex04qp9koj30j409a40d.jpg)
我们把有序表折半查找的过程用一棵 **二叉判定树（binary decision tree, BDT）**<img src="https://res.jisuanke.com/img/upload/20161216/9ca8b51f46323ed9e79761334908c1e462340cbc.png" alt="img" style="zoom:50%;" />表示
通过这样一棵树，我们可以很容易计算出折半查找算法查找成功的平均查找长度
*A**S**L*=1×1/6+2×2/6+3×3/6=7/3
而如果用顺序查找算法，平均查找长度为：3
可以看出，折半查找是比顺序查找更高效的查找算法。

```cpp
//1 3 5 7 9 10

int binary_search1(int *num, int n, int x) {
    int head = 0, tail = n - 1, mid;
    while(head <= tail) {
        mid = (head + tail) >> 1;
        if(num[mid] == x) return mid;
        if(num[mid] < x) head = mid + 1;
        else tail = mid - 1;
    }
    return -1;
}
```



**二分变形:**

>arr[mid] == 1; min = mid;
>arr[mid] != 1; max = mid - 1;

![2020-02-20 20-05-34屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex053axckj30hs0aq76m.jpg)

```cpp
//1111111000000
int binary_search2(int *num, int n) {
    int head = -1, tail = n - 1, mid;
    while(head < tail) {
        mid = (head + tail + 1) >> 1; //避免出现死循环
        if(num[mid] == 1) head = mid;
        else tail = mid - 1;
    }
    return head;
}
```

![2020-02-20 20-16-00屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex05cgk0oj30pb0e7wk5.jpg)

>arr[mid] == 1, max = mid;
>arr[mid] != 1, min = mid + 1;

```cpp
//000000111111
int binary_search3(int *num, int n) {
    int head = 0, tail = n, mid;
    while(head < tail) {
        mid = (head + tail) >> 1;
        if(num[mid] == 1)tail = mid;
        else head = mid + 1;
    }
    return head == n ? -1 : head;
}
```



#####　三分查找
![2020-02-20 20-08-57屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex05prap3j30l70amdht.jpg)

![2020-02-20 23-52-52屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex05yr1y8j30as04t0u6.jpg)



## ８.哈希表

思想：将任意类型的元素映射成整形直接索引
![2020-02-22 14-33-34屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex06ezzdoj30is072di9.jpg)
通过一个哈希函数，进行插入（有可能冲突），如果查找的时候，用哈希函数进行索引
冲突处理：![2020-02-22 14-37-02屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex06qcek1j30if06zdi7.jpg)
４大类冲突处理：**开放地址法，拉链法，再哈希法，建立公共溢出区**

```cpp
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

typedef struct Node { // 结构定义一个字符串类型的链表结点
    char *str;
    struct Node *next;
}Node;

typedef struct HashTable {　// 结构定义哈希表
    Node **data; //Node *类型的哈希表
    int size;
}HashTable;

Node *init_node(char *str, Node *head) {　//初始化一个字符串型的结点
    Node *p = (Node *)malloc(sizeof(Node));
    p->str = strdup(str);//将字符串赋值给p->str
    p->next = head;
    return p;
}

HashTable *init_hashtable(int n) {
    HashTable *h = (HashTable *)malloc(sizeof(HashTable));
    h->size = n << 1; //通常哈希表初始化为二倍的大小
    h->data = (Node **)calloc(h->size, sizeof(Node *));//清地址
/*calloc // 并初始化所有分配存储中的字节为零。
void* calloc( size_t num, size_t size ); 
为 num 个对象的数组分配内存，并初始化所有分配存储中的字节为零。
若分配成功，会返回指向分配内存块最低位（首位）字节的指针，它为任何类型适当地对齐。
若 size 为零，则行为是实现定义的（可返回空指针，或返回不可用于访问存储的非空指针）。
https://zh.cppreference.com/w/c/memory/calloc
*/
    return h;
}

int BKDRHash(char *str) {//将一个字符串的映射成整形
    int seed = 31, hash = 0;
    for(int i = 0; str[i]; i++) hash = hash * seed + str[i];
    return hash & 0x7fffffff;
}
/*
BKDRhash是通过前人研究出来，此时冲突是最少的，技巧
*/
int insert(HashTable *h, char *str) { //插入哈希表中
    int hash = BKDRHash(str);//获取字符串对应的整型数值
    int ind = hash % h->size; //通过哈希函数映射一个索引
    h->data[ind] = init_node(str, h->data[ind]); //将字符串插入对应的哈希表中
    return 1;
}

int search(HashTable *h, char *str) {//查找是否存在
    int hash = BKDRHash(str);
    int ind = hash % h->size;
    Node *p = h->data[ind]; //创建一个Node *类型的指针指向索引到的地方
    while(p && strcmp(p->str, str))p = p->next;//比较
    return p != NULL;//如果p为空，没找到
}


void clear_node(Node *node) { // 清空ｎｏｄｅ
    if(node == NULL) return;
    Node *p = node, *q; 
    while(p) {
        q = p->next;
        free(p->str);
        free(p);
        p = q;
    }
    free(q);
    return;
}


void clear_hashtablie(HashTable *h) {// 释放哈希表
    if(h == NULL) return;
    for(int i = 0; i < h->size; i++) clear_node(h->data[i]);//对哈希表上每一个链表释放
    free(h->data);
    free(h);
    return;
}

int main() {
    int op;
    #define max_n 100
    char str[max_n + 5];
    HashTable *h = init_hashtable(max_n + 5);
    while(~scanf("%d%s", &op, str)) {
        switch(op) {
            case 0:
            printf("insert %s to hash table\n", str);
            insert(h, str);
            break;
            case 1:
            printf("search %s from hash table tesult = %d\n", str, search(h, str));
            break;
        }
    }
    clear_hashtablie(h);
    return 0;
}

```

## ９.二叉排序树



二叉查找树的插入和查找效率相对较高，最坏情况下时间复杂度为  `O(n) `，期望的时间复杂度为 *`o(logn)`*，其中 `n `为树上结点总个数。
二叉查找树的基础上可以加些优化，可以让其成为 `AVL `树，红黑树，`SBT`，`Splay`
![2020-02-22 16-04-18屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex078fs1rj30kv0ayacc.jpg)
当中序遍历后他是个有序的数列，解决检索与排名

##### <font color = red>插入:</font>

![2020-02-22 16-11-03屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex07illiuj30kx094ta6.jpg)
10从头小于20往左走，小于17继续，大于3往右走：
![2020-02-22 16-12-56屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex07sojwyj30kt09d0uj.jpg)

1. 根节点为空则新元素直接作为根节点，否则传入的参数 value 与根节点进行比较。
2. value 等于当前节点则直接返回，小于则跳转到步骤 3，而如果 value 大于当前节点时，跳转到步骤 4。
3. 判断当前节点是否存在左孩子，如果存在则让其左孩子继续调用插入方法，回到步骤 2，如果不存在则将新元素插入到当前节点的左孩子位置上。
4. 判断当前节点是否存在右孩子，存在则让其右子树继续调用插入方法，回到步骤 2，不存在则将新元素插入到当前节点的右孩子位置上。

![img](https://res.jisuanke.com/img/upload/20161121/1d834bcad7f92b2202c9a67633f78028947f7b29.gif)插入一个值为８的元素



##### <font color = red>删除:</font>

1. 找到当前节点的左孩子，如果当前节点没有左孩子则不存在前驱，若存在，则找到其左孩子的右孩子。
2. 若当前节点有右孩子则继续找到其右孩子，重复步骤 2，直至找到一个节点不存在右孩子时，那么它就是我们要查找的前驱。
   1. 如果当前节点仅存在左孩子，则更新左孩子的父节点为被删除节点的父节点。
   2. 如果当前节点仅存在右孩子，则将其右孩子的父节点更新为被删除节点的父节点。
   3. 更新被删除节点的父节点的孩子指针，使其原本指向被删除节点的指针指向被删除节点的孩子节点。

![2020-02-22 16-15-47屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex081sa49j30l009fgnn.jpg)
１．删除叶子节点:直接删除
２．删除出度为１的节点:
![2020-02-22 16-16-25屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex08cgq9gj30l509dwgp.jpg)
提升３的唯一子树
３．删除度为２的结点：
![2020-02-22 16-22-58屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex08lrdpmj30kl09bju3.jpg)
找到前驱或者是后继替换掉，转换为度为１（０）的结点问题，
前驱为左边最大值，后继为右边的最小值
[17 18 19 20 28 29 30 32]
此处删除的时候先将19覆盖20然后删除19;

```cpp
#include<stdio.h>
#include<stdlib.h>

typedef struct Node{ //结构定义二叉树
    int key;
    struct Node *lchild, *rchild;
}Node;

Node *getNewNode(int key) {
    Node *p = (Node *)malloc(sizeof(Node));
    p->key = key;
    p->lchild = p->rchild = NULL;
    return p;
}

Node *insert(Node *root, int key) { //插入
    if(root == NULL) return getNewNode(key);
    if(root->key == key) return root;//如果插入的值等于根，插入失败
    if(key < root->key) root->lchild = insert(root->lchild, key);//如果插入的值小于root往左插入
    else root->rchild = insert(root->rchild, key);//如果插入的值大于root往右递归插入
    return root;
}

Node *predecessor(Node *root) { //找到前驱，就是左子树的最右结点
    Node *temp = root->lchild;
    while(temp->rchild)temp = temp -> rchild;
    return temp;
}

Node *erase(Node *root, int key) { // 删除结点
    if(root == NULL) return root;
    if(key < root->key) root->lchild = erase(root->lchild, key); //如果删除的值小于root那么向左递归找到删除
    else if(key > root->key) root->rchild = erase(root->rchild, key);//如果删除的值大于往右走
    else { //如果找到的话
        if(root->lchild == NULL || root->rchild == NULL) { //如果度为１或０
            Node *temp = root->lchild ? root->lchild : root->rchild; //建立一个中间变量记录左右结点，０度结点记录空
            free(root);//释放此节点
            return temp;//返回记录的他的左孩子还是右孩子
        } else {  //如果删除的度为２
            Node *temp = predecessor(root);//找到左子树最大的一个接点，也就是最右边的一个节点
            root->key = temp->key; //将它赋值给根
            root->lchild = erase(root->lchild, temp->key); // 然后从根把其左子树给递归删除释放掉
        }
    }
    return root;//返回结点；
}

void __in_order(Node *root) {
    if(root == NULL) return;
    __in_order(root->lchild);
    printf("%d ", root->key);
    __in_order(root->rchild);
    return;
} 

void in_order(Node *root) {
    printf("in_order output : ");
    __in_order(root);
    printf("\n");
    return;
}

void clear(Node *root) {
    if(root == NULL) return ;
    clear(root->lchild);
    clear(root->rchild);
    free(root);
    return;
}

 int main() {
     int op, val;
     Node *root = NULL;
     while(~scanf("%d%d", &op, &val)) {
         switch(op) {
             case 1: root = insert(root, val);break;
             case 2: root = erase(root, val);break;
         }
         in_order(root);
     }
     clear(root);
     return 0;
 }
```



![2020-02-22 16-36-15屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex08yi51hj30d500vt8r.jpg)



## 10.森林与并查集


**连通性问题**
1.基于<font color = red>染色</font>思想，一开始所有的点不同颜色
2.连接两个点的操作，可以看成<font color = blue>一种颜色</font>的点染成<font color = green>另一种颜色</font>
3.如果两个点颜色一样，证明联通，否则不连通
4.这种方法叫做并查集的：【Quick-Find算法】

##### QUICK-FIND算法

![2020-02-22 18-24-51屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex09bdqjhj30lb0andh3.jpg)
1.联通判断：O(1)
2.合并操作：O(n)
![2020-02-22 18-30-59屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex09inph7j30hd03rmyz.jpg)

quick-find :

```cpp
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
typedef struct UnionSet { //结构定义颜色和个数ｎ
    int *color;
    int n;
}UnionSet;

UnionSet *init(int n) {//初始化
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->color = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for(int i = 1; i <= n; i++) { //将其数组color每个值赋值为ｉ
        u->color[i] = i;
    }
    return u;
}

int find(UnionSet *u, int x) {//寻找x对应的颜色
    return u->color[x];
}

int merge(UnionSet *u, int a, int b) {//合并两种颜色
    if(find(u, a) == find(u, b)) return 0; //如果两种颜色相同则不进行合并
    int color_a = u->color[a];  //先记录一下颜色ａ
    for(int i = 1; i <= u->n; i++) { // 将所有与ａ相同颜色的设置成ｂ的颜色；
        if(u->color[i] != color_a) continue;
        u->color[i] = u->color[b];
    }
    return 1;
}

void clear(UnionSet *u) {
    if(u == NULL) return;
    free(u->color);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for(int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a ,&b, &c);
        switch(a) {
            case 1:merge(u, b, c); break;
            case 2:printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");break;
        }
    }
    clear(u);
    return 0;
}
```

----------------------------------------下一个优化算法-----------------------------------

##### QUICK-UNION算法
![2020-02-22 18-39-50屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex09ublw7j30lu0aztau.jpg)
![2020-02-22 19-08-10屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0a7svt3j30l708840u.jpg)

![2020-02-22 22-01-54屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0amd7tlj30jt06rmz2.jpg)

```cpp
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
typedef struct UnionSet { // 结构定义,父亲和个数
    int *father;
    int n;
}UnionSet;

UnionSet *init(int n) { // 初始化
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for(int i = 1; i <= n; i++) {//将每一个父节点设置成自己
        u->father[i] = i;
    }
    return u;
}

int find(UnionSet *u, int x) { // 查找ｘ的父亲是否是自己，知道查找到
    if(u->father[x] == x) return x;
    return find(u, u->father[x]);
}

int merge(UnionSet *u, int a, int b) {//合并
    int fa = find(u ,a), fb = find(u, b);//找到ａ的父亲，找到ｂ的父亲
    if(fa == fb) return 0; //如果同父亲不执行
    u->father[fa] = fb;//将ｂ子树合并到ａ
    return 1;
}

void clear(UnionSet *u) {
    if(u == NULL) return;
    free(u->father);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for(int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a ,&b, &c);
        switch(a) {
            case 1:merge(u, b, c); break;
            case 2:printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");break;
        }
    }
    clear(u);
    return 0;
}
```

##### WEIGHTED QYICK-UNION算法



优化：树低的连树高的上面，时间复杂度由`O(n)`<font color = red>-></font>`O(logn)`;

![2020-02-22 19-38-44屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0b1fgojj311k0lgag4.jpg)

![2020-02-22 19-45-42屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0bb55auj31010nf437.jpg)

![2020-02-22 19-55-11屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0blig7qj316p0jtage.jpg)

说明节点个数小的适合作为子树进行合并

![2020-02-22 19-57-43屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0bxtwozj30lm0axjtz.jpg)

![2020-02-22 22-02-50屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0cby7ujj30jm06p0un.jpg)

路径压缩：将０指向３
![2020-02-22 20-05-45屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0ckeliij30l8076jt8.jpg)
![2020-02-22 20-09-15屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0duzrn1j30l307qwgs.jpg)



```cpp
#include<stdio.h>
#include<string.h>
#include<stdlib.h>
#define swap(a, b) {\
    __typeof(a) __temp = a;\
    a = b; b = __temp;\
}

typedef struct UnionSet {
    int *father, *size;
    int n;
}UnionSet;

UnionSet *init(int n) {
    UnionSet *u = (UnionSet *)malloc(sizeof(UnionSet));
    u->father = (int *)malloc(sizeof(int) * (n + 1));
    u->size = (int *)malloc(sizeof(int) * (n + 1));
    u->n = n;
    for(int i = 1; i <= n; i++) {
        u->father[i] = i;
        u->size[i] = 1;
    }
    return u;
}

int find(UnionSet *u, int x) {
    return u->father[x] = (u->father[x] == x ? x : find(u, u->father[x])); //路径压缩
}

int merge(UnionSet *u, int a, int b) {
    int fa = find(u ,a), fb = find(u, b);
    if(fa == fb) return 0;
    if(u->size[fa] < u->size[fb])swap(fa, fb); //交换后ｂ作子树
    u->father[fa] = fb;
    u->size[fa] += u->size[fb];
    return 1;
}
/*
int merge(UnionSet *u, int a, int b) {
    int fa = find(u ,a), fb = find(u, b);
    if(fa == fb) return 0;
    if(u->size[fa] > u->size[fb]) { // 如果ｂ的结点少于ａ，则ｂ作子树
    u->father[fb] = fa;
    u->size[fa] += u->size[fb];
    } else {　// 反之
    u->father[fa] = fb;
    u->size[fb] += u->size[fa];
    }
    return 1;
}
*/
void clear(UnionSet *u) {
    if(u == NULL) return;
    free(u->father);
    free(u->size);
    free(u);
    return ;
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    UnionSet *u = init(n);
    for(int i = 0; i < m; i++) {
        int a, b, c;
        scanf("%d%d%d", &a ,&b, &c);
        switch(a) {
            case 1:merge(u, b, c); break;
            case 2:printf("%s\n", find(u, b) == find(u, c) ? "Yes" : "No");break;
        }
    }
    clear(u);
    return 0;
}
```



![2020-02-22 20-10-09屏幕截图.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gex0e7zknnj30cw02gwfb.jpg)







## 11.字符串匹配

### 暴力

```cpp
/*暴力*/
int brute_force(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    for(int i = 0, I = len1 - len2 + 1;i<I; i++) {
        int j = 0;
        for(; t[j]; j++) {
            if(t[j] == s[i + j])continue;
            break;
        }
        if(!t[j]) return i;
    }
    return -1;
}
```

### kmp

```cpp
/*KMP*/
int kmp(char *s, char *t) {
    int len1 = strlen(s);
    int len2 = strlen(t);
    int *next = (int *)malloc(sizeof(int) * len2);
    next[0] = -1;
    for(int i = 1, j = -1; i < len2; i++) {
        while(j != -1 && t[j + 1] != t[i]) j = next[j];
        if(t[j + 1] == t[i]) j+=1;
        next[i] = j;
    }
    for(int i = 0, j = -1; s[i]; i++) {
        while(j != -1 && t[j + 1] != s[i]) j = next[j];
        if(t[j + 1] == s[i]) j += 1;
        if(t[j + 1] == 0) return i - len2 + 1;
    }
    free(next);
    return -1;
}
```

### sunday

主要是黄金堆起点位

最优时间算法复杂度n / m;

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g1y9i62j30j707htbw.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g2jk6psj30jj07pgpb.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g2ugpegj30jo078n07.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g349d5nj30k107ktcc.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g4xr2zcj30k907kn0y.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g57kib3j30kw07a77k.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf0g5yhmwlj30l407v780.jpg)

```cpp
/*sunday*/
int sunday(char *s, char *t) {
    int ind[128] = {0};
    int len1 = strlen(s);
    int len2 = strlen(t);
    for(int i = 0; i < 128; i++) ind[i] = len2 + 1;
    for(int i = 0; t[i]; i++) ind[t[i]] = len2 - i;
    for(int i = 0, I = len1 - len2 + 1; i < I; ) {
        int flag = 1;
        for(int j = 0; j < len2; j++) {
            if(t[j] == s[i + j]) continue;
            i += ind[s[i + len2]];
            break;
        }
        if(flag) return i;
    }
    return -1;
}
```

### shift_and

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf07afogpkj30fr06cwgm.jpg)

![image-20200521173052961](../../../.config/Typora/typora-user-images/image-20200521173052961.png)

```cpp
/*shift_and*/
int shift_and(char *s, char *t) {
    int code[128] = {0};
    int len = 0;
    for(len = 0; t[len]; len++) {
        code[t[len]] |= (1 << len);
    }
    int p = 0;
    for(int i = 0; s[i]; i++) {
        p = (p << 1 | 1) & code[s[i]];
        if(p & (1 << (len - 1)))return i - len + 1;
    }
    return -1;
}
```



## 12. 树状数组

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf3l52rx9xj31cn0swn9t.jpg)

`C6 = a6 + a5     6=110   最低位权2`

`C7 = a7              7=111   最低位权1`

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf3l77xnmfj30tq0f50we.jpg)

6 + lowbit(6)包含C6

5 + lowbit(5) 包含c5

i->i+lowbit(i)

log<sub>2</sub>n

![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121208845-81274925.png)

- C[1] = A[1];

- C[2] = A[1] + A[2];

- C[3] = A[3];

- C[4] = A[1] + A[2] + A[3] + A[4];

- C[5] = A[5];

- C[6] = A[5] + A[6];

- C[7] = A[7];

- C[8] = A[1] + A[2] + A[3] + A[4] + A[5] + A[6] + A[7] + A[8];

  ![img](https://img2018.cnblogs.com/blog/1448672/201810/1448672-20181003121604644-268531484.png)

相比传统的前缀和单点修改时间复杂度是log级别，但是求区间和也是log,而传统是O(1)的

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vvr41toj30hs05340o.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vwa4t0aj30ki0bin1u.jpg)



![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vwr592bj30lw0bx79v.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vx0nohwj30l30bxwkn.jpg)

![image.png](http://ww1.sinaimg.cn/large/006Uqzbtly1gf4vxlog8oj30kh0buaeg.jpg)

**如果在做题中突然出现一个求累加和就往树状数组上想**

```cpp
#include<iostream>
#include<cstdio>
#include<cmath>
#include<cstring>
#include<iomanip>
#include<algorithm>
#include<map>
#include<vector>
using namespace std;
#define  MAX_N 1000
#define lowbit(x) ((x)&(-x))
int c[MAX_N + 5] = {0};

void add(int i,int val, int n) {
    while(i <= n) c[i] += val, i += lowbit(i);
    return;
}

int S(int i) {
    int sum = 0;
    while(i)sum += c[i], i -= lowbit(i);
    return sum;
}

int main() {
    int n, a;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a;
        add(i, a, n);
    }
    for(int i = 1; i <= n; i++) {
        cout << S(i) - S(i - 1) << endl;
    }
    return 0;
}
```

